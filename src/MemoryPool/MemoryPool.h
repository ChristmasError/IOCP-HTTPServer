#pragma once

#include "memorypool_global.h"

template<typename T, size_t Blocksize = 4096>
class MemoryPool
{
public:
	typedef       T				 value_type;
	typedef       T*		     pointer;
	typedef       T&			 reference;
	typedef const T*			 const_pointer;
	typedef const T&			 const_reference;
	typedef       size_t		 size_type;
	typedef		  ptrdiff_t		 difference_type;
	// ptrdiff_t: 是两个指针相减的结果的无符号整数类型
	// size_t : 是sizeof操作符的结构的无符号类型

	MemoryPool()  noexcept;
	~MemoryPool() noexcept;
	// 返回地址
	pointer address(reference x)const noexcept;
	const_pointer address(const_reference x)const noexcept;

	// 返回最多容纳元素数量
	size_type max_size()const noexcept;
	// 内存池中添加/删除新元素
	template <class... Args> pointer newElement(Args&&... args);
	void deleteElement(pointer p);

	pointer allocate(size_type n = 1, const_pointer hint = 0);			// 向内存池申请内存资源
	void deallocate(pointer p, size_type n = 1);						// 将内存资源返回给内存池			
	// 内存池元素的构造&析构
	template <class U, class... Args>void construct(U* p, Args&&... args);
	template <class U> void destroy(U* p);

private:
	// 内存池为线性链表，分Blok块储存，Slot_存放元素或next指针
	union Slot_
	{
		value_type element;
		Slot_*	   next;
	};
	typedef char*       data_pointer_;      
	typedef Slot_       slot_type_;			
	typedef Slot_*		slot_pointer_;

	slot_pointer_	BlockListHead_;			// 内存块链表头指针
	slot_pointer_	SlotListHead_;			// 元素链表头指针
	slot_pointer_	lastSlot_;				// 可存放元素的最后的指针
	slot_pointer_	FreeSlotHead;			// 元素构造后释放掉的内存链表头指针

	size_type padPointer(data_pointer_ p, size_type align) const noexcept;  // 计算对齐所需空间
	void allocateBlock();													// 申请将内存块放进内存池

};

/////////////////////////////////////////////////////////////////////////////
//							 						 					   //
//					 以下为MemoryPool模板类的实现						 	   //
//						 						 						   //
/////////////////////////////////////////////////////////////////////////////

template<typename T, size_t Blocksize>
inline typename MemoryPool<T, Blocksize>::size_type
MemoryPool<T, Blocksize>::padPointer(data_pointer_ p, size_type align) const noexcept
{
	size_t result = reinterpret_cast<size_t>(p);
	return ((align - result) % align);
}
// 构造函数
template<typename T, size_t Blocksize>
MemoryPool<T, Blocksize>::MemoryPool() noexcept
{
	BlockListHead_ = 0;
	SlotListHead_ = 0;
	lastSlot_ = 0;
	FreeSlotHead = 0;
}

// 析构函数，delete内存池中所有的block
template<typename T, size_t Blocksize>
MemoryPool<T, Blocksize>::~MemoryPool()
noexcept
{
	slot_pointer_ curr = BlockListHead_;
	while (curr != nullptr)//curr!=NULL
	{
		slot_pointer_ prev = curr->next;
		// 转化为void* 只释放空间不调用析构函数
		operator delete (reinterpret_cast<void*>(curr));
		curr = prev;
	}
}
// 返回地址
template<typename T, size_t Blocksize >
inline typename MemoryPool<T, Blocksize>::pointer
MemoryPool<T, Blocksize>::address(reference x)
const noexcept
{
	return &x;
}
// 返回地址 const 重载版本
template<typename T, size_t Blocksize>
inline typename MemoryPool<T, Blocksize>::const_pointer
MemoryPool<T, Blocksize>::address(const_reference x)
const noexcept
{
	return &x;
}
// 申请一块空闲的Block放入内存池
template<typename T, size_t Blocksize>
void MemoryPool<T, Blocksize>::allocateBlock()
{
	// operator new（）申请一块Blocksize大小的内存
	data_pointer_ newBlock = reinterpret_cast<data_pointer_>(operator new(Blocksize));
	// 新Block链表头 BlockListHead_
	reinterpret_cast<slot_pointer_>(newBlock)->next = BlockListHead_;
	BlockListHead_ = reinterpret_cast<slot_pointer_>(newBlock);
	// 计算为了对齐应该空出多少位置
	data_pointer_ body = newBlock + sizeof(slot_pointer_);
	size_type bodyPadding = padPointer(body, sizeof(slot_type_));
	// currentslot_ 为该 block 开始的地方加上 bodypadding 个 char* 空间
	SlotListHead_ = reinterpret_cast<slot_pointer_>(body + bodyPadding);
	// 计算最后一个能放下slot_type_的位置
	lastSlot_ = reinterpret_cast<slot_pointer_>(newBlock + Blocksize - sizeof(slot_type_) + 1);
}

// 返回指向分配新元素所需内存的指针
template<typename T, size_t Blocksize>
inline typename MemoryPool<T, Blocksize>::pointer
MemoryPool<T, Blocksize>::allocate(size_type n, const_pointer hint)
{
	// 如果freeSlot_非空，就在freeSlot_中去取内存
	if (FreeSlotHead != nullptr)
	{
		pointer pElement = reinterpret_cast<pointer>(FreeSlotHead);
		FreeSlotHead = FreeSlotHead->next;
		return pElement;
	}
	else
	{
		// Block中内存用完的情况
		if (SlotListHead_ >= lastSlot_)
			allocateBlock();
		return reinterpret_cast<pointer>(SlotListHead_++);
	}
}
// 将元素内存归还free内存链表
template<typename T, size_t Blocksize>
inline void
MemoryPool<T, Blocksize>::deallocate(pointer p, size_type n)
{
	if (p != nullptr)
	{
		// 转换成slot_pointer_指针，next指向freeslots_链表
		reinterpret_cast<slot_pointer_>(p)->next = FreeSlotHead;
		FreeSlotHead = reinterpret_cast<slot_pointer_>(p);
	}
}

// 计算最大元素上限数 
template<typename T, size_t Blocksize>
inline typename MemoryPool<T, Blocksize>::size_type
MemoryPool<T, Blocksize>::max_size()
const noexcept
{
	size_type maxBlocks = -1 / Blocksize;
	return ((Blocksize - sizeof(data_pointer_)) / sizeof(slot_type_) * maxBlocks);
}

// 在已分配内存上构造对象
template <typename T, size_t BlockSize>
template <class U, class... Args>
inline void
MemoryPool<T, BlockSize>::construct(U* p, Args&&... args)
{
	new (p) U(std::forward<Args>(args)...);
}

// 销毁对象
template<typename T, size_t Blocksize>
template <class U>
inline void
MemoryPool<T, Blocksize>::destroy(U* p)
{
	p->~U();
	// 调用析构
}

// 创建新元素
template<typename T, size_t Blocksize>
template <class... Args>
inline typename  MemoryPool<T, Blocksize>::pointer
MemoryPool<T, Blocksize>::newElement(Args&&... args)
{
	// 申请内存
	pointer pElement = allocate();
	// 在内存上构造对象
	construct<value_type>(pElement, std::forward<Args>(args)...);
	return pElement;
}
// 删除元素
template<typename T, size_t Blocksize>
inline void
MemoryPool<T, Blocksize>::deleteElement(pointer p)
{
	if (p != nullptr)
	{
		p->~value_type();
		deallocate(p);
	}
}